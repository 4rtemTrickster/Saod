#include <iostream>
#include <vector>

using namespace std;

vector<int> graph[100000];
bool used[100000] = { false };
vector<int> order;    //массив для сохранения пронумерованных вершин

//Стоит отметить, что такая реализация не проверяет возможность построения топологической сортировки.
//Если в графе существуют циклы, она проигнорирует их и выведет неправильный ответ.
void dfs(int v) 
{
    used[v] = true;

    for (int u : graph[v]) 
        if (!used[u]) 
            dfs(u);

    order.push_back(v);
}

int main()
{
    int n, m;       //количество вершин и рёбер соответственно
    setlocale(LC_ALL, "Rus");
    cout << "Введите кол-во вершин и ребер соответсветственно:";
    cin >> n >> m;

    cout << "Введите номера вершин, соединённых очередным ребром:" << endl;
    for (int i = 0; i < m; i++) 
    {
        int u, v;
        cin >> u >> v;
        cout << endl;
        u--, v--;               //Чаще всего в задачах вершины нумерeруются с 1 до N,
                                //в отличие от индексации массивов в C++.
                                //У этой проблемы есть два решения.
                                //Первое: работать с номерами "как есть": создавать массивы размером N + 1,
                                //использовать циклы от 1 до N, и т.д.
                                //Второе: уменьшать номера вершин на единицу при вводе, и увеличивать обратно при выводе
        graph[u].push_back(v);
        graph[v].push_back(u);
    }  
  


    for (int i = 0; i < n; i++)             //чтобы DFS посетил все вершины графа,
        if (!used[i])                       //а не только достижимые из нулевой. Поэтому мы явно
            dfs(i);                         //вызываем его для всех, ещё не посещённых ранее.
    

   reverse(order.begin(), order.end());

    cout << "Topological sort: ";
    for (int v : order)
        cout << v + 1 << ", ";

	return 0;
}